<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Funciones en Python: organiza y reutiliza tu código</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            background: #f4f6f7; 
            color: #2c3e50;
        }
        header {
            background: #3498db;
            color: white;
            padding: 20px;
            text-align: center;
        }
        nav {
            background: #2980b9;
            padding: 10px;
            text-align: center;
        }
        nav a {
            margin: 0 15px;
            text-decoration: none;
            color: white;
            font-weight: bold;
        }
        nav a:hover { text-decoration: underline; }
        main {
            padding: 40px;
            max-width: 980px;
            margin: auto;
        }
        h1, h2, h3 { color: #2c3e50; }
        .code-box {
            background: #272822;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            margin-top: 10px;
            overflow-x: auto;
        }
        .sintaxis {
            margin-top: 10px;
            padding: 12px;
            background: #d6eaf8;
            border-left: 5px solid #1f618d;
            font-family: monospace;
        }
        .explicacion {
            margin-top: 10px;
            padding: 15px;
            background: #ecf0f1;
            border-left: 5px solid #3498db;
        }
        ul {
            background: #ecf0f1;
            padding: 16px 20px;
            border-radius: 5px;
        }
        footer {
            
            background: #bdc3c7;
            text-align: center;
            padding: 15px;
            margin-top: 40px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <header>
        <h1>Funciones en Python: organiza y reutiliza tu código</h1>
        <p>Agrupá instrucciones en bloques reutilizables</p>
    </header>

    <nav>
        <a href="index.html">Inicio</a>
        <a href="condicionales.html">Condicionales</a>
        <a href="bucles.html">Bucles</a>
        <a href="funciones.html">Funciones</a>
        <a href="ejercicios.html">Ejercicios para practicar</a>

    </nav>

    <main>
            <h2>¿Qué es una función?</h2>
    <p>
        Una <strong>función</strong> es un bloque de código que agrupa instrucciones bajo un nombre. 
        Se define una vez y se puede reutilizar muchas veces en diferentes partes del programa. 
        Esto permite <strong>organizar</strong> el código, <strong>evitar repeticiones</strong> y hacerlo más <strong>legible</strong>.
    </p>
    <p>
        Podés pensar en una función como una <em>receta</em>: la escribís una vez y cada vez que quieras preparar ese plato, 
        simplemente seguís los pasos sin tener que volver a inventarlos.
    </p>

    <div class="explicacion">
        <strong>Ventajas de usar funciones:</strong>
        <ul>
            <li>Reutilización de código: definís una vez, usás muchas.</li>
            <li>Organización: dividís el programa en partes más claras.</li>
            <li>Mantenimiento: si hay un error, lo corregís en un solo lugar.</li>
            <li>Colaboración: facilita que varias personas trabajen en el mismo proyecto.</li>
        </ul>
    </div>

    <h2>Sintaxis de una función</h2>
    <p>La estructura general es:</p>

    <div class="sintaxis">
def nombre_funcion(parámetros):
    # bloque de código
    return valor
    </div>

    <div class="explicacion">
        <ul>
            <li><code>def</code>: palabra clave para definir la función.</li>
            <li><code>nombre_funcion</code>: identificador descriptivo (ej: <code>calcular_area</code>).</li>
            <li><code>parámetros</code>: valores que recibe la función (opcionales).</li>
            <li><code>return</code>: devuelve un resultado (opcional).</li>
        </ul>
    </div>

    <h2>¿Qué es un parámetro y cómo se pasa?</h2>
<p>
Un <strong>parámetro</strong> es una variable que la función usa como entrada. 
Cuando llamamos a la función, le pasamos un <strong>argumento</strong> (el valor real). 
Por ejemplo, en <code>def saludar_persona(nombre):</code>, <code>nombre</code> es el parámetro. 
Al llamar <code>saludar_persona("Ana")</code>, <code>"Ana"</code> es el argumento.
</p>

<div class="explicacion">
<strong>Reglas clave:</strong>
<ul>
  <li><strong>Posicionales:</strong> los argumentos se asignan por su posición: el primer valor va al primer parámetro, etc.</li>
  <li><strong>Nombrados:</strong> podés indicar a qué parámetro va cada valor usando <code>clave=valor</code>, sin depender del orden.</li>
  <li><strong>Orden:</strong> si usás argumentos posicionales, respetá el orden de los parámetros definidos.</li>
</ul>
</div>

    <h2>Funciones con un parámetro</h2>
<p>
Una función con un parámetro recibe un único valor y lo usa dentro de su bloque de código. 
Es la forma más simple de personalizar el comportamiento de una función.
</p>

<div class="code-box">
# Definición
def saludar_persona(nombre):
    print("Hola", nombre)

# Llamadas (ejecuciones)
saludar_persona("Ana")
saludar_persona("Luis")
</div>

<div class="code-box">
# Salida en consola:
Hola Ana
Hola Luis
</div>

<div class="explicacion">
<strong>Qué pasa al llamar:</strong> el valor entre paréntesis se asigna al parámetro <code>nombre</code>. 
Luego el cuerpo de la función usa ese valor. <br>
<strong>Error común:</strong> llamar sin argumento (<code>saludar_persona()</code>) provoca un error porque falta el valor para <code>nombre</code>.
</div>

    <h2>Funciones con dos parámetros</h2>
<p>
Las funciones pueden recibir varios valores. Si llamás con argumentos <strong>posicionales</strong>, 
se asignan por orden; si llamás con <strong>nombrados</strong>, indicás explícitamente cada parámetro.
</p>

<div class="code-box">
# Definición
def sumar(a, b):
    resultado = a + b
    print("La suma es:", resultado)

# Llamadas con argumentos posicionales (por orden)
sumar(5, 3)

# Llamadas con argumentos nombrados (clave=valor)
sumar(a=10, b=4)
sumar(b=4, a=10)  # el orden ya no importa
</div>

<div class="code-box">
# Salida en consola:
La suma es: 8
La suma es: 14
La suma es: 14
</div>

<div class="explicacion">
<strong>Posicionales:</strong> el primer valor va a <code>a</code>, el segundo a <code>b</code>. <br>
<strong>Nombrados:</strong> podés escribir <code>a=</code> y <code>b=</code> para indicar el destino, sin depender del orden. <br>
<strong>Mejor práctica:</strong> usá argumentos nombrados cuando quieres que el código sea más claro y resistente a cambios de orden.
</div>

    <h2>Funciones con tres parámetros</h2>
<p>
A medida que aumenta la cantidad de parámetros, la claridad del llamado se vuelve más importante. 
Los <strong>argumentos nombrados</strong> ayudan a evitar confusiones.
</p>

<div class="code-box">
# Definición
def presentar_persona(nombre, edad, ciudad):
    print("Me llamo", nombre, "tengo", edad, "años y vivo en", ciudad)

# Llamada posicional (por orden)
presentar_persona("Carlos", 30, "Buenos Aires")

# Llamada con argumentos nombrados (más explícita)
presentar_persona(nombre="Ana", edad=25, ciudad="Rosario")
</div>

<div class="code-box">
# Salida en consola:
Me llamo Carlos tengo 30 años y vivo en Buenos Aires
Me llamo Ana tengo 25 años y vivo en Rosario
</div>

<div class="explicacion">
<strong>Legibilidad:</strong> con varios parámetros, preferí argumentos nombrados para que sea claro qué valor va a cada uno. <br>
<strong>Orden:</strong> en llamadas posicionales, respetá el orden definido en la función; en llamadas nombradas, el orden deja de importar.
</div>

    <h2>Parámetros con valores por defecto</h2>
<p>
Podés asignar un <strong>valor por defecto</strong> a un parámetro al definir la función. 
Si no pasás ese argumento al llamar la función, se usa el valor por defecto; si lo pasás, se reemplaza.
</p>

<div class="code-box">
# Definición con valor por defecto
def saludar_persona(nombre="visitante"):
    print("Hola", nombre)

# Llamadas
saludar_persona()            # usa el valor por defecto
saludar_persona("Tomas")     # reemplaza el valor por defecto
</div>

<div class="code-box">
# Salida en consola:
Hola visitante
Hola Tomas
</div>

<div class="explicacion">
<strong>Regla de orden:</strong> los parámetros con valor por defecto van <em>después</em> de los obligatorios. <br>
Ejemplo correcto: <code>def f(a, b=0): ...</code> — Incorrecto: <code>def f(a=0, b): ...</code>. <br>
<strong>Ventaja:</strong> permite llamadas más flexibles y reduce repetición de valores comunes.
</div>

    <h2>Combinar argumentos posicionales y nombrados</h2>
<p>
Podés mezclar ambos tipos en una llamada, pero los <strong>posicionales deben ir primero</strong>, 
seguido de los <strong>nombrados</strong>.
</p>

<div class="code-box">
def generar_usuario(nombre, rol="alumno", activo=True):
    print("Usuario:", nombre, "| Rol:", rol, "| Activo:", activo)

# Correcto: primero posicional, luego nombrados
generar_usuario("Ana", rol="moderadora", activo=False)

# Incorrecto: nombrados antes que posicionales (provoca error)
# generar_usuario(rol="moderadora", "Ana")
</div>

<div class="code-box">
# Salida en consola:
Usuario: Ana | Rol: moderadora | Activo: False
</div>

<div class="explicacion">
<strong>Regla:</strong> los argumentos posicionales deben aparecer antes que los nombrados en la llamada. <br>
<strong>Consejo:</strong> usá nombrados para parámetros opcionales o cuando quieras claridad sin depender del orden.
</div>

    <h2>Errores comunes con parámetros</h2>
<div class="explicacion">
<ul>
  <li><strong>Olvidar pasar argumentos obligatorios:</strong> llamar <code>sumar()</code> sin valores cuando la función espera <code>a</code> y <code>b</code>.</li>
  <li><strong>Confundir posicionales con el orden:</strong> llamar <code>presentar_persona(30, "Carlos", "Buenos Aires")</code> no coincide con <code>(nombre, edad, ciudad)</code>.</li>
  <li><strong>Parámetros por defecto mal ubicados:</strong> poner un parámetro opcional antes de uno obligatorio.</li>
  <li><strong>Usar solo <code>print</code> cuando se quería <code>return</code>:</strong> si necesitás el resultado fuera de la función, devolvelo con <code>return</code>.</li>
  <li><strong>Reutilizar nombres que confunden:</strong> variables con el mismo nombre que una función pueden causar errores o lecturas confusas.</li>
</ul>
</div>

    <h2>¿Qué hace return?</h2>
<p>
<code>return</code> <strong>devuelve un valor</strong> desde una función al lugar donde fue llamada y <strong>detiene</strong> la ejecución de esa función. 
Sin <code>return</code>, la función devuelve <code>None</code> por defecto y no se puede reutilizar su resultado.
</p>

<div class="code-box">
# Sin return: solo imprime
def saludar():
    print("Hola")

# Con return: devuelve un dato reutilizable
def obtener_saludo():
    return "Hola"

# Llamadas
saludar()                      # muestra en consola
texto = obtener_saludo()       # guarda el resultado
print("Recibido:", texto)
</div>

<div class="code-box">
# Salida en consola:
Hola
Recibido: Hola
</div>

<div class="explicacion">
<strong>Print vs return:</strong> <code>print</code> muestra en pantalla (efecto visual), <code>return</code> devuelve un valor (para usarlo luego). 
Usá <code>return</code> cuando necesites <em>resultados</em> que se pasen a otras partes del programa (asignar a variables, componer, testear).
</div>

    <h2>¿Cuándo usar return?</h2>
<div class="explicacion">
<ul>
  <li><strong>Cuando el resultado se necesita más adelante:</strong> cálculos, filtros, transformaciones.</li>
  <li><strong>Para separar lógica de presentación:</strong> la función <em>devuelve datos</em>; otra parte decide si imprimirlos o guardarlos.</li>
  <li><strong>Para testear funciones:</strong> devolver valores permite escribir pruebas y comparar resultados esperados.</li>
  <li><strong>Para terminar antes:</strong> si ya tenés el resultado, podés retornar y cortar el flujo (return anticipado).</li>
</ul>
</div>

    <h2>Calcular y devolver un resultado</h2>
<p>Una función suele procesar datos y <strong>devolver</strong> el resultado con <code>return</code>.</p>

<div class="code-box">
# Definición
def sumar(a, b):
    return a + b

# Llamada (ejecución)
resultado = sumar(5, 3)
print("La suma es:", resultado)
</div>

<div class="code-box">
# Salida en consola:
La suma es: 8
</div>

<div class="explicacion">
La función no imprime: <strong>devuelve</strong> el resultado. Eso permite reutilizarlo (mostrarlo, guardarlo, compararlo). 
Si hicieras <code>print(a + b)</code> dentro de la función, perderías la posibilidad de usar ese valor en otro lugar.
</div>

    <h2>Return anticipado</h2>
<p>Si encontrás el resultado durante un bucle o una condición, podés cortar y devolverlo al instante.</p>

<div class="code-box">
# Definición: devolver el primer número par
def primer_par(numeros):
    for n in numeros:
        if n % 2 == 0:
            return n   # corta la función aquí
    return None         # si no hay pares

# Llamada
print("Primer par:", primer_par([3, 5, 9, 12, 13]))
</div>

<div class="code-box">
# Salida en consola:
Primer par: 12
</div>

<div class="explicacion">
<strong>Patrón recomendado:</strong> retornar apenas tengas el resultado. 
Usá un <strong>valor por defecto</strong> (ej. <code>None</code>) cuando no se encuentre, y documentalo en la explicación.
</div>

    <h2>Múltiples returns por caso</h2>
<p>Podés devolver valores distintos según la lógica del problema.</p>

<div class="code-box">
def clasificar_nota(nota):
    if nota >= 9:
        return "Excelente"
    elif nota >= 6:
        return "Aprobado"
    else:
        return "Desaprobado"

# Llamadas
print(clasificar_nota(9))
print(clasificar_nota(7))
print(clasificar_nota(3))
</div>

<div class="code-box">
# Salida en consola:
Excelente
Aprobado
Desaprobado
</div>

<div class="explicacion">
Cada <code>return</code> cierra la función con un resultado claro. 
Este estilo es más legible que acumular variables y retornar al final sin necesidad.
</div>

    <h2>Devolver listas para reutilizar los datos</h2>
<p>En funciones que transforman colecciones, devolvé la nueva lista con <code>return</code>.</p>

<div class="code-box">
def filtrar_pares(numeros):
    pares = []
    for n in numeros:
        if n % 2 == 0:
            pares.append(n)
    return pares

# Llamada
resultado = filtrar_pares([1, 2, 3, 4, 5, 6])
print("Pares:", resultado)
</div>

<div class="code-box">
# Salida en consola:
Pares: [2, 4, 6]
</div>

<div class="explicacion">
<strong>Buena práctica:</strong> no imprimas dentro de funciones que generan datos. 
Devolvé la colección y dejá que otra parte decida cómo presentarla (print, guardar, enviar).
</div>

    <h2>¿Que pasa si no uso return?</h2>
<p>Una función sin <code>return</code> <strong>devuelve None</strong> por defecto, aunque imprima algo.</p>

<div class="code-box">
def saludar():
    print("Hola")

resultado = saludar()  # la función imprime, pero su valor es None
print("Valor devuelto:", resultado)
</div>

<div class="code-box">
# Salida en consola:
Hola
Valor devuelto: None
</div>

<div class="explicacion">
Si necesitas el resultado para reutilizarlo, <strong>usa return</strong>. 
Si solo querés mostrar algo en pantalla, <code>print</code> es suficiente.
</div>

    <h2>Devolver múltiples valores</h2>
<p>Podés retornar varios resultados a la vez usando una tupla.</p>

<div class="code-box">
def stats(numeros):
    cantidad = len(numeros)
    total = sum(numeros)
    promedio = total / cantidad if cantidad > 0 else 0
    return cantidad, total, promedio

# Llamada y desempaquetado
n, s, p = stats([10, 20, 30])
print("n:", n, "| suma:", s, "| prom:", p)
</div>

<div class="code-box">
# Salida en consola:
n: 3 | suma: 60 | prom: 20.0
</div>

<div class="explicacion">
El <code>return</code> puede devolver varios valores separados por coma (se empaquetan en una tupla). 
Luego podés <strong>desempaquetar</strong> al recibirlos para trabajar con cada uno.
</div>

    <h2>Cómo se llama una función</h2>
<p>
Definir una función no la ejecuta automáticamente. Para que el código dentro de la función se ejecute, 
debemos <strong>llamarla</strong> (o invocarla). 
Esto se hace escribiendo el <code>nombre_de_la_funcion</code> seguido de paréntesis <code>()</code>.
</p>

<div class="code-box">
# Definición
def saludar():
    print("¡Hola!")

# Llamada (ejecución)
saludar()
</div>

<div class="code-box">
# Salida en consola:
¡Hola!
</div>

<div class="explicacion">
<strong>Importante:</strong>  
Si escribís solo <code>saludar</code> (sin paréntesis), Python no ejecuta la función, 
sino que muestra una referencia a ella.  
Para que se ejecute, siempre hay que usar los paréntesis: <code>saludar()</code>.
</div>

    <h2 class="titulo-destacado">Ejemplos de funciones</h2>

<h3>Ejemplo 1: función sin parámetros</h3>
<div class="code-box">
# Definición
def saludar():
    print("¡Hola, bienvenido a Python!")

# Llamada (ejecución)
saludar()
</div>

<div class="code-box">
# Salida en consola:
¡Hola, bienvenido a Python!
</div>

<div class="explicacion">
La función <code>saludar()</code> no recibe parámetros.  
Se ejecuta siempre igual cada vez que la llamamos.
</div>


<h3>Ejemplo 2: función con un parámetro</h3>
<div class="code-box">
# Definición
def saludar_persona(nombre):
    print("Hola", nombre)

# Llamadas
saludar_persona("Ana")
saludar_persona("Luis")
</div>

<div class="code-box">
# Salida en consola:
Hola Ana
Hola Luis
</div>

<div class="explicacion">
La función <code>saludar_persona(nombre)</code> recibe un valor y lo usa dentro del mensaje.
</div>


<h3>Ejemplo 3: función con retorno</h3>
<div class="code-box">
# Definición
def sumar(a, b):
    return a + b

# Llamada
resultado = sumar(5, 3)
print("La suma es:", resultado)
</div>

<div class="code-box">
# Salida en consola:
La suma es: 8
</div>

<div class="explicacion">
En este caso, la función <code>sumar(a, b)</code> devuelve un valor con <code>return</code>.  
Ese valor se puede guardar en una variable o usar en otra operación.
</div>

<!-- Estilo para resaltar el título -->
<style>
  .titulo-destacado {
    background: #d6eaf8;          /* azul claro */
    border-left: 6px solid #1f618d; /* borde azul oscuro */
    padding: 10px 15px;
    border-radius: 5px;
    color: #1f618d;
    font-weight: bold;
    margin-top: 40px;
  }
</style>

<h2 class="titulo-destacado">Errores comunes al usar funciones</h2>

<h3>1. Olvidar los paréntesis al llamar la función</h3>
<div class="code-box">
def saludar():
    print("Hola")

# Incorrecto: solo referencia la función
print(saludar)

# Correcto: llamada con paréntesis
saludar()
</div>

<div class="code-box">
# Salida en consola:
<function saludar at 0x000001...>   # referencia, no ejecución
Hola
</div>

<div class="explicacion">
<strong>Error:</strong> escribir <code>saludar</code> sin paréntesis no ejecuta la función, solo muestra su referencia en memoria.  
<strong>Solución:</strong> siempre llamá con paréntesis: <code>saludar()</code>.
</div>


<h3>2. No pasar los argumentos necesarios</h3>
<div class="code-box">
def sumar(a, b):
    return a + b

# Incorrecto: falta un argumento
# sumar(5)

# Correcto: pasar ambos argumentos
print(sumar(5, 3))
</div>

<div class="code-box">
# Salida en consola:
8
</div>

<div class="explicacion">
<strong>Error:</strong> si la función espera dos parámetros y le das uno, Python lanza un <code>TypeError</code>.  
<strong>Solución:</strong> asegurate de pasar todos los argumentos requeridos.
</div>


<h3>3. Confundir print con return</h3>
<div class="code-box">
def sumar_print(a, b):
    print(a + b)   # solo muestra en pantalla

def sumar_return(a, b):
    return a + b   # devuelve el valor

# Llamadas
x = sumar_print(2, 3)
y = sumar_return(2, 3)
print("x:", x)
print("y:", y)
</div>

<div class="code-box">
# Salida en consola:
5
x: None
y: 5
</div>

<div class="explicacion">
<strong>Error:</strong> usar <code>print</code> cuando querías guardar el resultado.  
<strong>Solución:</strong> usá <code>return</code> si necesitás reutilizar el valor.
</div>


<h3>4. Reutilizar nombres de variables y funciones</h3>
<div class="code-box">
def saludar():
    print("Hola")

saludar()   # funciona

# Error: sobrescribimos el nombre de la función
saludar = "texto"
saludar()   # ahora da error
</div>

<div class="explicacion">
<strong>Error:</strong> usar el mismo nombre para una variable y una función sobrescribe la función.  
<strong>Solución:</strong> elegí nombres distintos y descriptivos.
</div>


<h3>5. Orden incorrecto de parámetros</h3>
<div class="code-box">
def presentar_persona(nombre, edad, ciudad):
    print("Me llamo", nombre, "tengo", edad, "años y vivo en", ciudad)

# Incorrecto: orden equivocado
presentar_persona(30, "Carlos", "Buenos Aires")

# Correcto: respetar el orden
presentar_persona("Carlos", 30, "Buenos Aires")
</div>

<div class="code-box">
# Salida en consola:
Me llamo Carlos tengo 30 años y vivo en Buenos Aires
</div>

<div class="explicacion">
<strong>Error:</strong> en llamadas posicionales, el orden importa.  
<strong>Solución:</strong> respetá el orden definido o usá argumentos nombrados (<code>presentar_persona(nombre="Carlos", edad=30, ciudad="Buenos Aires")</code>).
</div>


<h3>6. Parámetros por defecto mal ubicados</h3>
<div class="code-box">
# Incorrecto: parámetro con valor por defecto antes de uno obligatorio
# def f(a=0, b):   # SyntaxError

# Correcto: los opcionales van al final
def f(a, b=0):
    return a + b

print(f(5))
print(f(5, 3))
</div>

<div class="code-box">
# Salida en consola:
5
8
</div>

<div class="explicacion">
<strong>Error:</strong> los parámetros con valor por defecto no pueden ir antes de los obligatorios.  
<strong>Solución:</strong> siempre ponelos al final de la lista de parámetros.
</div>

<footer>
    &copy; 2025 — primeros pasos en Python <br>
    Creado por <strong>Tomás Sánchez Paez</strong> ❤️ y publicados
</footer>